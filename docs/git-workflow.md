# Работа с ветками Git и GitHub

Пошаговая инструкция: как вносить изменения, отправлять на GitHub и объединять с основной веткой.

---

## Общая схема работы

```
1. Создать ветку → 2. Внести изменения → 3. Закоммитить →
4. Отправить на GitHub → 5. (Опционально) Промежуточное сохранение →
6. Создать PR → 7. Смержить → 8. Обновить локальный main
```

---

## Шаг 1: Создание новой ветки

```bash
git checkout -b название-ветки
```

**Что делает:** Создаёт новую ветку и сразу переключается на неё.

**Пример:**
```bash
git checkout -b add-new-feature
```

**Правила именования веток:**
- Используй латиницу и дефисы
- Называй по смыслу изменений: `fix-parser-bug`, `add-telegram-bot`, `update-docs`

---

## Шаг 2: Внесение изменений

Редактируй файлы как обычно. Проверяй статус:

```bash
git status
```

**Что покажет:**
- **Changes not staged for commit** — изменённые файлы (красные)
- **Untracked files** — новые файлы, которые Git ещё не отслеживает
- **Changes to be committed** — файлы, готовые к коммиту (зелёные)

---

## Шаг 3: Добавление файлов в индекс

### Добавить все изменения:
```bash
git add .
```

### Добавить конкретный файл:
```bash
git add имя_файла.py
```

### Добавить несколько файлов:
```bash
git add файл1.py файл2.py папка/
```

**Что делает:** Помечает файлы для включения в следующий коммит. Файлы попадают в "индекс" (staging area).

---

## Шаг 4: Создание коммита

```bash
git commit -m "Описание изменений"
```

**Что делает:** Сохраняет изменения из индекса в историю Git.

**Правила хороших сообщений:**
- Пиши кратко и по делу
- Начинай с глагола: "Добавил", "Исправил", "Обновил"
- Примеры:
  - `"Добавил поддержку GitHub в парсер"`
  - `"Исправил баг с кодировкой"`
  - `"Обновил документацию"`

---

## Шаг 5: Отправка ветки на GitHub

```bash
git push origin название-ветки
```

**Что делает:** Загружает твою ветку на GitHub.

**Пример:**
```bash
git push origin add-new-feature
```

При первой отправке новой ветки Git может предложить команду с `--set-upstream` — просто скопируй и выполни её.

---

## Шаг 5.1: Промежуточное сохранение незавершенной работы

**Ситуация:** Ты работаешь над веткой `fix-bot`, но не успел закончить за сегодня. Нужно сохранить прогресс, выключить компьютер и продолжить завтра.

### Вариант А: Коммит незавершенной работы (WIP) — рекомендуется

Используй, когда код работает, но функционал ещё не завершён.

```bash
# 1. Проверь изменения
git status

# 2. Добавь файлы [ОБЯЗАТЕЛЬНО]
git add .

# 3. Создай промежуточный коммит [ОБЯЗАТЕЛЬНО]
git commit -m "WIP: добавил обработку ошибок в бот"

# 4. Отправка на GitHub [НЕОБЯЗАТЕЛЬНО]
git push origin fix-bot
```

**На следующий день:**
```bash

# Когда всё готово, сделай финальный коммит
git add .
git commit -m "Завершил обработку ошибок и добавил тесты"

# Отправь готовую ветку на GitHub
git push origin fix-bot
```

**Что такое WIP?**
- **WIP** = Work In Progress (работа в процессе)
- Префикс показывает, что это промежуточное сохранение
- Такие коммиты остаются локально, не засоряют GitHub

### Вариант Б: Git Stash — для экспериментов

Используй, когда код вообще не готов к коммиту (эксперименты, сломанный код).

```bash
# 1. Сохрани изменения в "тайник" (stash)
git stash save "эксперимент с новым парсером"

# 2. Посмотри список сохранений
git stash list
```

**На следующий день:**
```bash
# 1. Посмотри список сохранений
git stash list
# Выведет: stash@{0}: On fix-bot: эксперимент с новым парсером

# 2. Восстанови изменения
git stash pop
# Восстанавливает изменения и удаляет из stash

# ИЛИ
git stash apply
# Восстанавливает, но оставляет копию в stash
```

### Сравнение подходов

| Метод | Когда использовать | Плюсы |
|-------|-------------------|-------|
| **WIP коммит** | Код работает, но не завершён | Сохраняется в истории, можно откатиться |
| **Git stash** | Эксперименты, сломанный код | Не засоряет историю коммитов |

---

## Шаг 7: Создание Pull Request на GitHub

1. Открой репозиторий на GitHub
2. Увидишь жёлтую плашку: **"add-new-feature had recent pushes"**
3. Нажми кнопку **"Compare & pull request"**
4. Заполни описание (опционально)
5. Нажми **"Create pull request"**

---

## Шаг 8: Слияние (Merge) в основную ветку

### Вариант А: Через GitHub (рекомендуется)

1. На странице Pull Request нажми **"Merge pull request"**
2. Подтверди нажатием **"Confirm merge"**
3. Можно удалить ветку кнопкой **"Delete branch"**

### Вариант Б: Локально

```bash
git checkout main
git merge название-ветки
git push origin main
```

---

## Шаг 9: Обновление локальной основной ветки

После merge на GitHub твой локальный `main` отстаёт. Обнови его:

```bash
git checkout main
git pull origin main
```

**Что делает:**
- `checkout main` — переключается на ветку main
- `pull origin main` — скачивает изменения с GitHub и применяет их

---

## Полный пример рабочего цикла

```bash
# 1. Убедись, что main актуален
git checkout main
git pull origin main

# 2. Создай ветку для новой задачи
git checkout -b add-ollama-support

# 3. ... редактируй файлы ...

# 4. Проверь изменения
git status

# 5. Добавь файлы
git add .

# 6. Закоммить
git commit -m "Добавил поддержку Ollama"

# 7. Отправь на GitHub
git push origin add-ollama-support

# 8. Создай PR на GitHub и смержь

# 9. Обнови локальный main
git checkout main
git pull origin main
```

---

## Полезные команды

| Команда | Описание |
|---------|----------|
| `git status` | Показать состояние файлов |
| `git branch` | Показать список веток |
| `git branch -a` | Показать все ветки (включая удалённые) |
| `git log --oneline` | Краткая история коммитов |
| `git diff` | Показать изменения в файлах |
| `git checkout main` | Переключиться на ветку main |
| `git branch -d ветка` | Удалить локальную ветку |
| `git stash save "описание"` | Сохранить незавершённые изменения во временное хранилище |
| `git stash list` | Показать список сохранённых изменений |
| `git stash pop` | Восстановить последние сохранённые изменения и удалить из stash |
| `git stash apply` | Восстановить изменения, но оставить копию в stash |

---

## Частые ошибки

### "Your branch is behind"
Твоя ветка отстала от GitHub. Решение:
```bash
git pull origin main
```

### Забыл переключиться с main перед изменениями
Если уже начал редактировать в main:
```bash
git checkout -b новая-ветка
```
Изменения перенесутся в новую ветку.

### Конфликт слияния (merge conflict)
Git не смог автоматически объединить изменения. Открой файлы с конфликтами, выбери нужную версию, затем:
```bash
git add .
git commit -m "Разрешил конфликт"
```
