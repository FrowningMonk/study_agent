# Работа с ветками Git и GitHub

Пошаговая инструкция: как вносить изменения, отправлять на GitHub и объединять с основной веткой.

---

## Общая схема работы

```
1. Создать ветку → 2. Внести изменения → 3. Закоммитить →
4. Отправить на GitHub → 5. (Опционально) Промежуточное сохранение →
6. Создать PR → 7. Смержить → 8. Обновить локальный main
```

---

## Шаг 1: Создание новой ветки

```bash
git checkout -b название-ветки
```

**Что делает:** Создаёт новую ветку и сразу переключается на неё.

**Пример:**
```bash
git checkout -b add-new-feature
```

**Правила именования веток:**
- Используй латиницу и дефисы
- Называй по смыслу изменений: `fix-parser-bug`, `add-telegram-bot`, `update-docs`

---

## Шаг 2: Внесение изменений

Редактируй файлы как обычно. Проверяй статус:

```bash
git status
```

**Что покажет:**
- **Changes not staged for commit** — изменённые файлы (красные)
- **Untracked files** — новые файлы, которые Git ещё не отслеживает
- **Changes to be committed** — файлы, готовые к коммиту (зелёные)

---

## Шаг 3: Добавление файлов в индекс

### Добавить все изменения:
```bash
git add .
```

### Добавить конкретный файл:
```bash
git add имя_файла.py
```

### Добавить несколько файлов:
```bash
git add файл1.py файл2.py папка/
```

**Что делает:** Помечает файлы для включения в следующий коммит. Файлы попадают в "индекс" (staging area).

---

## Шаг 4: Создание коммита

```bash
git commit -m "Описание изменений"
```

**Что делает:** Сохраняет изменения из индекса в историю Git.

**Правила хороших сообщений:**
- Пиши кратко и по делу
- Начинай с глагола: "Добавил", "Исправил", "Обновил"
- Примеры:
  - `"Добавил поддержку GitHub в парсер"`
  - `"Исправил баг с кодировкой"`
  - `"Обновил документацию"`

---

## Шаг 5: Отправка ветки на GitHub

```bash
git push origin название-ветки
```

**Что делает:** Загружает твою ветку на GitHub.

**Пример:**
```bash
git push origin add-new-feature
```

При первой отправке новой ветки Git может предложить команду с `--set-upstream` — просто скопируй и выполни её.

---

## Шаг 5.1: Промежуточное сохранение незавершенной работы

**Ситуация:** Ты работаешь над веткой `fix-bot`, но не успел закончить за сегодня. Нужно сохранить прогресс, выключить компьютер и продолжить завтра.

### Вариант А: Коммит незавершенной работы (WIP) — рекомендуется

Используй, когда код работает, но функционал ещё не завершён.

```bash
# 1. Проверь изменения
git status

# 2. Добавь файлы [ОБЯЗАТЕЛЬНО]
git add .

# 3. Создай промежуточный коммит [ОБЯЗАТЕЛЬНО]
git commit -m "WIP: добавил обработку ошибок в бот"

# 4. Отправка на GitHub [НЕОБЯЗАТЕЛЬНО]
git push origin fix-bot
```

**На следующий день:**
```bash

# Когда всё готово, сделай финальный коммит
git add .
git commit -m "Завершил обработку ошибок и добавил тесты"

# Отправь готовую ветку на GitHub
git push origin fix-bot
```

**Что такое WIP?**
- **WIP** = Work In Progress (работа в процессе)
- Префикс показывает, что это промежуточное сохранение
- Такие коммиты остаются локально, не засоряют GitHub

### Вариант Б: Git Stash — для экспериментов

Используй, когда код вообще не готов к коммиту (эксперименты, сломанный код).

```bash
# 1. Сохрани изменения в "тайник" (stash)
git stash save "эксперимент с новым парсером"

# 2. Посмотри список сохранений
git stash list
```

**На следующий день:**
```bash
# 1. Посмотри список сохранений
git stash list
# Выведет: stash@{0}: On fix-bot: эксперимент с новым парсером

# 2. Восстанови изменения
git stash pop
# Восстанавливает изменения и удаляет из stash

# ИЛИ
git stash apply
# Восстанавливает, но оставляет копию в stash
```

### Сравнение подходов

| Метод | Когда использовать | Плюсы |
|-------|-------------------|-------|
| **WIP коммит** | Код работает, но не завершён | Сохраняется в истории, можно откатиться |
| **Git stash** | Эксперименты, сломанный код | Не засоряет историю коммитов |

---

## Шаг 7: Создание Pull Request на GitHub

1. Открой репозиторий на GitHub
2. Увидишь жёлтую плашку: **"add-new-feature had recent pushes"**
3. Нажми кнопку **"Compare & pull request"**
4. Заполни описание (опционально)
5. Нажми **"Create pull request"**

---

## Шаг 8: Слияние (Merge) в основную ветку

### Вариант А: Через GitHub (рекомендуется)

1. На странице Pull Request нажми **"Merge pull request"**
2. Подтверди нажатием **"Confirm merge"**
3. Можно удалить ветку кнопкой **"Delete branch"**

### Вариант Б: Локально

```bash
git checkout main
git merge название-ветки
git push origin main
```

---

## Шаг 9: Обновление локальной основной ветки

После merge на GitHub твой локальный `main` отстаёт. Обнови его:

```bash
git checkout main
git pull origin main
```

**Что делает:**
- `checkout main` — переключается на ветку main
- `pull origin main` — скачивает изменения с GitHub и применяет их

---

## Полный пример рабочего цикла

```bash
# 1. Убедись, что main актуален
git checkout main
git pull origin main

# 2. Создай ветку для новой задачи
git checkout -b add-ollama-support

# 3. ... редактируй файлы ...

# 4. Проверь изменения
git status

# 5. Добавь файлы
git add .

# 6. Закоммить
git commit -m "Добавил поддержку Ollama"

# 7. Отправь на GitHub
git push origin add-ollama-support

# 8. Создай PR на GitHub и смержь

# 9. Обнови локальный main
git checkout main
git pull origin main
```

---

## Полезные команды

| Команда | Описание |
|---------|----------|
| `git status` | Показать состояние файлов |
| `git branch` | Показать список веток |
| `git branch -a` | Показать все ветки (включая удалённые) |
| `git log --oneline` | Краткая история коммитов |
| `git diff` | Показать изменения в файлах |
| `git checkout main` | Переключиться на ветку main |
| `git branch -d ветка` | Удалить локальную ветку |
| `git stash save "описание"` | Сохранить незавершённые изменения во временное хранилище |
| `git stash list` | Показать список сохранённых изменений |
| `git stash pop` | Восстановить последние сохранённые изменения и удалить из stash |
| `git stash apply` | Восстановить изменения, но оставить копию в stash |

---

## Частые ошибки

### "Your branch is behind"
Твоя ветка отстала от GitHub. Решение:
```bash
git pull origin main
```

### Забыл переключиться с main перед изменениями
Если уже начал редактировать в main:
```bash
git checkout -b новая-ветка
```
Изменения перенесутся в новую ветку.

### Конфликт слияния (merge conflict)
Git не смог автоматически объединить изменения. Открой файлы с конфликтами, выбери нужную версию, затем:
```bash
git add .
git commit -m "Разрешил конфликт"
```

---

## Работа с внешними ветками (агенты, другие разработчики)

Claude Code и другие агенты создают ветки через `git worktree` — это отдельные рабочие директории, привязанные к веткам вида `claude/название-задачи`. Ветки появляются локально, но не видны на GitHub, пока их не запушат.

---

### Шаг 1: Посмотреть, какие ветки создали агенты

```bash
# Все локальные ветки (включая агентские)
git branch

# Ветки с последним коммитом — удобно для обзора
git branch -v

# Если агент уже запушил ветку на GitHub
git fetch origin
git branch -a
```

Ветки агентов обычно имеют префикс `claude/`, например `claude/hardcore-newton`.

---

### Шаг 2: Проверить изменения в ветке агента (ДО мерджа)

```bash
# Посмотреть коммиты, которых нет в main
git log main..claude/hardcore-newton --oneline

# Посмотреть что именно изменено (диф относительно main)
git diff main..claude/hardcore-newton

# Посмотреть список изменённых файлов
git diff main..claude/hardcore-newton --stat
```

**Совет:** Всегда проверяй диф перед мерджем. Агент мог допустить ошибку или внести лишние изменения.

---

### Шаг 3: Протестировать ветку агента локально

Если хочешь запустить код из ветки перед мерджем:

```bash
# Вариант А: Переключиться на ветку агента
git checkout claude/hardcore-newton
# ... тестируешь ...
git checkout main  # вернуться обратно

# Вариант Б: Посмотреть через worktree (если агент работал через worktree)
# Код уже лежит в папке worktree, можно зайти и проверить
```

---

### Шаг 4: Смержить ветку агента в main

```bash
# 1. Убедись, что main актуален
git checkout main
git pull origin main

# 2. Смержи ветку агента
git merge claude/hardcore-newton

# 3. Если конфликты — разреши их, потом:
git add .
git commit -m "Разрешил конфликт при мердже claude/hardcore-newton"

# 4. Отправь на GitHub
git push origin main
```

---

### Шаг 5: Навести порядок после мерджа

```bash
# Удалить локальную ветку агента
git branch -d claude/hardcore-newton

# Если агент работал через worktree — удалить worktree
git worktree list                              # посмотреть все worktree
git worktree remove путь/к/worktree            # удалить

# Если ветка была на GitHub — удалить удалённую
git push origin --delete claude/hardcore-newton
```

---

### Альтернатива: через Pull Request (рекомендуется для важных изменений)

Если хочешь ревью на GitHub перед мерджем:

```bash
# 1. Запушить ветку агента на GitHub
git push origin claude/hardcore-newton

# 2. Создать PR через CLI
gh pr create --base main --head claude/hardcore-newton \
  --title "Описание изменений" \
  --body "Что сделано и зачем"

# 3. Посмотреть PR в браузере, проверить диф
# 4. Смержить через GitHub или CLI
gh pr merge --merge
```

---

### Полный пример: агент создал ветку, ты проверяешь и мерджишь

```bash
# 1. Посмотри что есть
git branch -v

# 2. Проверь изменения
git log main..claude/hardcore-newton --oneline
git diff main..claude/hardcore-newton --stat

# 3. Если всё ок — мерджи
git checkout main
git pull origin main
git merge claude/hardcore-newton
git push origin main

# 4. Убери за собой
git branch -d claude/hardcore-newton
```

---

### Полезные команды для работы с внешними ветками

| Команда | Описание |
|---------|----------|
| `git branch -v` | Список веток с последним коммитом |
| `git log main..ветка --oneline` | Коммиты ветки, которых нет в main |
| `git diff main..ветка --stat` | Какие файлы изменены в ветке |
| `git diff main..ветка` | Полный диф ветки относительно main |
| `git merge ветка` | Смержить ветку в текущую |
| `git worktree list` | Список всех worktree |
| `git worktree remove путь` | Удалить worktree |
| `gh pr create --head ветка` | Создать PR из ветки |
| `gh pr merge` | Смержить PR через CLI |
